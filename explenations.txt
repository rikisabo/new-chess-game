
מצוין! עכשיו אפשר להתחיל בניתוח והסבר מעמיק של הפרויקט.

מבנה כללי של הפרויקט
הפרויקט הוא משחק שחמט (או וריאציה שלו, כנראה Kung Fu Chess) עם דגש על עקרונות תכנות מונחה עצמים, דיזיין פטרנים, הפרדה בין לוגיקה לגרפיקה, ותמיכה במצבים שונים לכל כלי.

עקרונות עיצוב עיקריים (Design Patterns)
State Pattern: כל כלי נמצא ב-state (מצב) מסוים, וכל מעבר בין מצבים (למשל idle, move, jump) מתבצע דרך אובייקט State. זה מאפשר להפריד התנהגות של הכלי לפי מצבו.
Factory Pattern: יצירת כלים, פיזיקה, גרפיקה נעשית דרך מחלקות Factory (למשל PieceFactory, PhysicsFactory, GraphicsFactory).
Command Pattern: פעולות של שחקן (move, jump וכו') נארזות כאובייקט Command, שמכיל את כל המידע הדרוש לביצוע הפעולה.
Publisher-Subscriber/Event Pattern: יש Publisher ו-Subscriber לאירועים במשחק (למשל תזוזה, לכידה, התחלה/סיום משחק).
MVC Separation: יש הפרדה בין הלוגיקה (Game, Piece, State) לגרפיקה (Graphics, Img) ולקלט (KeyboardInput).
הסבר על קבצים עיקריים
Board.py
מייצג את לוח המשחק.
משתנים:

cell_H_pix, cell_W_pix: גובה/רוחב תא בפיקסלים.
W_cells, H_cells: מספר תאים לרוחב/גובה.
img: אובייקט Img שמייצג את התמונה של הלוח.
cell_H_m, cell_W_m: גובה/רוחב תא במטרים (לשימוש בפיזיקה/גרפיקה).
פונקציות:

clone(): יוצר עותק של הלוח (כולל תמונה).
show(): מציג את הלוח.
m_to_cell, cell_to_m, m_to_pix: המרות בין מטרים, תאים, פיקסלים.
למה כך?
ההפרדה בין יחידות (פיקסלים/מטרים/תאים) מאפשרת גמישות בגרפיקה ובפיזיקה.

Game.py
מנהל את כל מהלך המשחק: לולאת המשחק, קלט, עדכון מצב, ציור, בדיקת ניצחון.

משתנים:

pieces: רשימת כל הכלים.
board: הלוח.
user_input_queue: תור פקודות מהשחקנים.
piece_by_id: מיפוי מזהה כלי לאובייקט.
pos: מיפוי תא לרשימת כלים (לזיהוי התנגשויות).
kp1, kp2: KeyboardProcessor לכל שחקן.
kb_prod_1, kb_prod_2: KeyboardProducer לכל שחקן.
selected_id_1/2: מזהה הכלי שנבחר ע"י כל שחקן.
פונקציות עיקריות:

run(): מפעיל את המשחק.
start_user_input_thread(): מפעיל קלט משני שחקנים.
_run_game_loop(): לולאת המשחק הראשית.
_process_input(): מעבד פקודה (Command) ע"י קריאה ל־on_command של הכלי.
_resolve_collisions(): מזהה התנגשויות בין כלים בתא.
_draw(), _show(): מצייר את הלוח והכלים.
למה כך?
הפרדה ברורה בין לוגיקת המשחק, קלט, ציור, וטיפול בהתנגשויות. שימוש ב־queue מאפשר עבודה עם תהליכים/threads.

Piece.py
מייצג כלי בודד.

משתנים:

id: מזהה ייחודי לכלי (כולל סוג, צבע, מיקום).
state: מצב נוכחי (State).
פונקציות:

on_command(cmd, cell2piece): מעביר פקודה ל־State.
reset(start_ms): מאפס את הכלי למצב התחלתי.
update(now_ms): מעדכן את מצב הכלי (כולל פיזיקה).
draw_on_board(board, now_ms): מצייר את הכלי על הלוח.
current_cell(): מחזיר את התא הנוכחי של הכלי.
למה כך?
כל ההתנהגות של הכלי תלויה במצבו (State), מה שמאפשר הרחבה קלה למצבים חדשים.

State.py
מייצג מצב של כלי (idle, move, jump וכו').

משתנים:

moves: אובייקט Moves שמכיל את כללי התנועה למצב זה.
graphics: אובייקט Graphics שמכיל את האנימציה למצב זה.
physics: אובייקט Physics שמכיל את הפיזיקה למצב זה.
transitions: מיפוי מאירוע (פקודה) למצב הבא.
name: שם המצב.
פונקציות:

on_command(cmd, cell2piece, my_color): בודק אם יש מעבר למצב אחר לפי הפקודה, ומבצע מעבר אם אפשרי.
update(now_ms): מעדכן פיזיקה וגרפיקה, ומבצע מעבר אוטומטי אם צריך.
can_be_captured, can_capture: האם הכלי במצב זה יכול להילכד/ללכוד.
למה כך?
State Pattern קלאסי – כל מצב אחראי להתנהגות שלו ולמעברים ממנו.

PieceFactory.py
Factory ליצירת כלים.

פונקציות:

_build_state_machine(piece_dir): בונה מכונת מצבים לכלי לפי קבצי states.
create_piece(p_type, cell): יוצר כלי חדש עם מכונת מצבים.
למה כך?
מאפשר הרחבה קלה – כל כלי מוגדר ע"י קבצים, לא קוד.

Physics.py + PhysicsFactory.py
מגדירים את הפיזיקה של הכלי (איך הוא נע, האם הוא חוסם תנועה, האם אפשר ללכוד אותו וכו').

פיזיקות עיקריות:

IdlePhysics: סטטי.
MovePhysics: נע בין תאים.
JumpPhysics: קופץ מיידית.
RestPhysics: מנוחה.
למה כך?
הפרדה בין לוגיקת מצב (State) לפיזיקה בפועל.

Moves.py
מכיל את כללי התנועה של כלי במצב מסוים, נטען מקובץ moves.txt.

פונקציות:

is_valid(src_cell, dst_cell, ...): האם מותר לעבור מתא לתא.
_path_is_clear(...): האם הדרך פנויה.
למה כך?
מאפשר להגדיר חוקים שונים לכל כלי ולכל מצב ע"י קובץ.

Graphics.py + GraphicsFactory.py + img.py
אחראים על טעינת תמונות, אנימציות, ציור הכלים והלוח.

KeyboardInput.py
מטפל בקלט מהמקלדת, כולל תמיכה בשני שחקנים, מיפוי מקשים, ותמיכה בעברית.

EventType.py, GameEventPublisher.py, Subscriber.py
מימוש בסיסי של Event Publisher/Subscriber – מאפשר להאזין לאירועים במשחק (כמו תזוזה, לכידה, התחלה/סיום).

סיכום דיזיין פטרנים עיקריים
State Pattern – לכל כלי יש מצב, וכל מצב אחראי להתנהגות שלו.
Factory Pattern – יצירת כלים, פיזיקה, גרפיקה.
Command Pattern – כל פעולה נארזת כאובייקט Command.
Publisher/Subscriber – אירועים במשחק.
MVC – הפרדה בין לוגיקה, גרפיקה וקלט.
יתרונות
הרחבה קלה: הוספת כלי/מצב/אנימציה/פיזיקה – רק ע"י קבצים.
בדיקות קלות: כל רכיב מופרד, אפשר להחליף גרפיקה/פיזיקה/קלט.
תמיכה בריבוי שחקנים: קלט עצמאי לכל שחקן.
חסרונות/אתגרים
מורכבות: הרבה קבצים, הרבה שכבות הפשטה.
ביצועים: שימוש ב־threading, תורים, עשוי להיות איטי אם לא ממומש נכון.
רוצה הסבר מפורט על קובץ/פונקציה/מחלקה מסוימת?
או דוגמה ל־flow של פקודה (move/jump) מתחילתו ועד סופו?
או דיאגרמת מחלקות/מצבים?
כתבי לי מה להעמיק!

 (טקסטואליות) של מחלקות ומצבים, ואחריו דוגמה של זרימת פעולה (flow) של פקודת "move" מרגע הלחיצה ועד שהכלי זז.

דיאגרמת מחלקות (Class Diagram) – עיקריות
דיאגרמת מצבים (State Machine) – דוגמה לכלי
לכל מצב יש חצים (מעברים) לפי סוג הפקודה (move, jump, rest וכו').
כל מצב אחראי להתנהגות שלו ולמעבר למצב הבא.
דוגמה: איך פקודת "move" מתבצעת בפועל
1. שחקן לוחץ על מקש (למשל Enter) כשהסמן על כלי
KeyboardProducer מזהה את הלחיצה, בודק אם יש כלי בתא, ואם כן – שומר את ה־id שלו כ־selected_id.
2. שחקן בוחר תא יעד ולוחץ שוב Enter
KeyboardProducer יוצר אובייקט Command עם:
סוג: "move"
מזהה הכלי
תא מקור ותא יעד
הפקודה מוכנסת ל־user_input_queue של Game.
3. Game קורא מהתור ומעביר לפונקציה _process_input
מוצא את הכלי לפי id.
קורא ל־piece.on_command(cmd, cell2piece).
4. Piece קורא ל־state.on_command(cmd, cell2piece, my_color)
בודק אם יש מעבר חוקי (transition) ל־"move".
בודק אם המהלך חוקי (Moves.is_valid).
אם כן, יוצר מצב חדש (State) ומבצע reset (מאפס פיזיקה/גרפיקה).
5. בלולאת המשחק, Game קורא ל־piece.update(now_ms)
זה קורא ל־state.update(now_ms), שמעדכן את הפיזיקה (האם הכלי הגיע ליעד).
אם הפיזיקה סיימה – מתבצע מעבר אוטומטי למצב הבא (למשל rest או idle).
6. Game מצייר את הלוח והכלים במיקומם החדש.
המחשה בשפה פשוטה
את/ה בוחר/ת כלי עם הסמן ולוחץ/ת Enter – המערכת זוכרת איזה כלי בחרת.
את/ה מזיז/ה את הסמן לתא אחר ולוחץ/ת שוב Enter – המערכת יוצרת "פקודת תזוזה" (move) עם כל הפרטים.
המשחק בודק אם המהלך חוקי (לפי החוקים של הכלי והמצב שלו).
אם כן, הכלי עובר למצב "בתנועה" – הפיזיקה מתחילה להזיז אותו.
כשהכלי מגיע ליעד, הוא חוזר למצב "מנוחה".
המסך מתעדכן – רואים את הכלי במקום החדש.
אם תרצי דיאגרמה גרפית (UML) או הסבר על flow אחר (למשל jump או capture), או פירוט על מחלקה מסוימת – אשמח להמשיך!

דוגמה איך פקודת  מתבצעת בפועל
1. שחקן לוחץ על מקש (למשל Enter) כשהסמן על כלי
KeyboardProducer מזהה את הלחיצה, בודק אם יש כלי בתא, ואם כן – שומר את ה־id שלו כ־selected_id.
2. שחקן בוחר תא יעד ולוחץ שוב Enter
KeyboardProducer יוצר אובייקט Command עם:
סוג: "move"
מזהה הכלי
תא מקור ותא יעד
הפקודה מוכנסת ל־user_input_queue של Game.
3. Game קורא מהתור ומעביר לפונקציה _process_input
מוצא את הכלי לפי id.
קורא ל־piece.on_command(cmd, cell2piece).
4. Piece קורא ל־state.on_command(cmd, cell2piece, my_color)
בודק אם יש מעבר חוקי (transition) ל־"move".
בודק אם המהלך חוקי (Moves.is_valid).
אם כן, יוצר מצב חדש (State) ומבצע reset (מאפס פיזיקה/גרפיקה).
5. בלולאת המשחק, Game קורא ל־piece.update(now_ms)
זה קורא ל־state.update(now_ms), שמעדכן את הפיזיקה (האם הכלי הגיע ליעד).
אם הפיזיקה סיימה – מתבצע מעבר אוטומטי למצב הבא (למשל rest או idle).
6. Game מצייר את הלוח והכלים במיקומם החדש.
המחשה בשפה פשוטה
את/ה בוחר/ת כלי עם הסמן ולוחץ/ת Enter – המערכת זוכרת איזה כלי בחרת.
את/ה מזיז/ה את הסמן לתא אחר ולוחץ/ת שוב Enter – המערכת יוצרת "פקודת תזוזה" (move) עם כל הפרטים.
המשחק בודק אם המהלך חוקי (לפי החוקים של הכלי והמצב שלו).
אם כן, הכלי עובר למצב "בתנועה" – הפיזיקה מתחילה להזיז אותו.
כשהכלי מגיע ליעד, הוא חוזר למצב "מנוחה".
המסך מתעדכן – רואים את הכלי במקום החדש.
אם תרצי דיאגרמה גרפית (UML) או הסבר על flow אחר (למשל jump או capture), או פירוט על מחלקה מסוימת – אשמח להמשיך!


+-------------------+
|      Game         |
+-------------------+
| pieces            |
| board             |
| user_input_queue  |
| ...               |
+-------------------+
| run()             |
| _process_input()  |
| ...               |
+-------------------+
         |
         | 1..* (contains)
         v
+-------------------+
|     Piece         |
+-------------------+
| id                |
| state             |
+-------------------+
| on_command()      |
| update()          |
| ...               |
+-------------------+
         |
         | 1 (has)
         v
+-------------------+
|     State         |
+-------------------+
| moves             |
| graphics          |
| physics           |
| transitions       |
+-------------------+
| on_command()      |
| update()          |
| ...               |
+-------------------+
         |
         | 1 (has)
         v
+-------------------+
|   BasePhysics     |<--+-- IdlePhysics
+-------------------+   +-- MovePhysics
| ...               |   +-- JumpPhysics
+-------------------+   +-- RestPhysics

+-------------------+
|    Graphics       |
+-------------------+
| frames            |
| ...               |
+-------------------+

+-------------------+
|     Moves         |
+-------------------+
| moves             |
| ...               |
+-------------------+